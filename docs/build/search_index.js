var documenterSearchIndex = {"docs":
[{"location":"#ExactPredicates.jl-1","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"This package provides two important predicates for geometry in the Euclidean plane: orient and incircle.","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"This package provides two important predicates for geometry in the Euclidean plane: orient and incircle.","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"They are ports in Julia of the CGAL C++ predicates, implemented by Sylvain Pion. They use floating point arithmetic and fallback to slow exact arithmetic when required. The algorithm has been proved robust and correct in a formal proof system by Guillaume Melquiond and Sylvain Pion (“Formal certification of arithmetic filters for geometric predicates”, IMACS 2005) in all cases:","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"underflows and overflows in the floating point computation;\ndegenerate configurations (collinear points, colliding vertices, etc.).","category":"page"},{"location":"#Robustness-1","page":"ExactPredicates.jl","title":"Robustness","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"Robust means that the code:","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"raises an exception on NaN and Inf arguments;\ngives a correct answer on all other inputs with Float64 coordinates, no matter what.","category":"page"},{"location":"#Type-for-points-1","page":"ExactPredicates.jl","title":"Type for points","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"The basic type for representing points in the plane is Complex{Float64} (a.k.a. ComplexF64). To define the predicates for a type T, simply define complex(T).","category":"page"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"using ExactPredicates\nimport Base: complex\n\nstruct Point\n    x :: Float64\n    y :: Float64\nend\n\ncomplex(p :: Point) = complex(p.x, p.y)\n\nincircle(Point(0.0, 0.0), Point(1.0, 0.0), Point(0.0, 1.0), Point(.5, .5))","category":"page"},{"location":"#License-1","page":"ExactPredicates.jl","title":"License","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"The package is released under the LGPLv3 license, or any later version, as required by CGAL's license.","category":"page"},{"location":"#Exported-functions-1","page":"ExactPredicates.jl","title":"Exported functions","text":"","category":"section"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"orient(p, q, r)","category":"page"},{"location":"#ExactPredicates.orient-Tuple{Any,Any,Any}","page":"ExactPredicates.jl","title":"ExactPredicates.orient","text":"orient(p, q, r) -> Int\n\nReturn 1 if r is on the left of the oriented line defined by p and q. Return -1 if r is on the right. Return 0 if r is on the line or if p == q.\n\nThe result is guaranteed to be correct if p, q and r are Complex{Float64} values, or faithfully convertible to Complex{Float64} values via complex.\n\n\n\n\n\n","category":"method"},{"location":"#","page":"ExactPredicates.jl","title":"ExactPredicates.jl","text":"incircle(a, b, c, p)","category":"page"},{"location":"#ExactPredicates.incircle-NTuple{4,Any}","page":"ExactPredicates.jl","title":"ExactPredicates.incircle","text":"incircle(a, b, c, p) -> Int\n\nAssume that a, b and c define a counterclockwise triangle. Return 1 if p is strictly inside the circumcircle of this triangle. Return -1 if p is outside. Return 0 if p is on the circle.\n\nIf the triangle is oriented clockwise, the signs are reversed. If a, b and c are collinear, this degenerate to an orientation test.\n\nIf two of the four arguments are equal, return 0.\n\nThe result is guaranteed to be correct if a, b, c and p are Complex{Float64} values, or faithfully convertible to Complex{Float64} values via complex.\n\n\n\n\n\n","category":"method"}]
}
